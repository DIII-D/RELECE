import numpy as np
from scipy.constants import m_e, c, e
from scipy import special
from scipy import interpolate
from scipy import integrate
import matplotlib.pyplot as plt


class Distribution:
    """
    Base class for arbitrary electron momentum distributions.

    This class is designed to accept arbitrary output from some radial
    coordinate in CQL3D and therefore follows its conventions.

    Parameters
    ----------
    f : ndarray
        The distribution function values. Must be broadcastable to the
        coordinate grid defined by `u` and `theta`.
    u : ndarray
        The normalized momentum per mass, defined as ``p / m_e``.
    theta : ndarray
        The polar angle in radians from 0 to pi.
    normalize : bool
        Whether to normalize the given distribution. If `f` is
        generated by CQL3D or is normalized to `u`, this should be set
        to `True`. Default is `True`.

    Attributes
    ----------
    f : ndarray
        The distribution function.
    p : ndarray
        The absolute electron momentum array.
    theta : ndarray
        The polar angle in radians from 0 to pi.

    Methods
    -------
    ev : float
        Gets the interpolated points along the resonance ellipse.

    """

    def __init__(self, f, u, theta):
        self._validate_input(f, u, theta)
        p = u / (1e2 * c)  # c is in SI units, u in CGS.
        self.f = self._normalize(f, p, theta)
        self.p = p
        self.theta = theta
        self._spline = interpolate.RectBivariateSpline(
            self.p, self.theta, self.f
        )

    @staticmethod
    def _validate_input(f, u, theta):
        if u.ndim != 1 or theta.ndim != 1:
            raise ValueError("`u` and `theta` must be 1D arrays.")
        if f.shape != (len(u), len(theta)):
            raise ValueError("`f` must have shape ``(len(u), len(theta)).``")

    @staticmethod
    def _normalize(f, p, theta):
        """`f` is normalized over 3D momentum space."""
        jacobian = 2 * np.pi * p[:, None]**2 * np.sin(theta[None, :])
        integral = integrate.simpson(integrate.simpson(f * jacobian, p, axis=0), theta)

        if np.isclose(integral, 1.0):
            return f
        print(f"Distribution is not normalized (momentum volume is {integral}).\
              Normalizing...")
        return f / integral

    def ev(self, p_perp, p_par):
        """Gets the interpolated points along the resonance ellipse."""
        p = np.hypot(p_perp, p_par)
        theta = np.arctan2(p_perp, p_par)
        return self._spline(p, theta, grid=False)

    def grad(self, p_perp, p_par):
        """Gets the gradient of the distribution at given points."""
        p = np.hypot(p_perp, p_par)
        theta = np.arctan2(p_perp, p_par)
        grad_p = self._spline(p, theta, dx=1, dy=0, grid=False)
        grad_theta = self._spline(p, theta, dx=0, dy=1, grid=False) / p

        grad_par = grad_p * np.cos(theta) - grad_theta * np.sin(theta)
        grad_perp = grad_p * np.sin(theta) + grad_theta * np.cos(theta)
        return grad_perp, grad_par


class MaxwellJuttnerDistribution(Distribution):
    """
    Generate Maxwell-Juttner distribution.

    This is a `Distribution` subclass that generates a 2D polar
    distribution for relativistic thermal plasma.

    Parameters
    ----------
    temperature : scalar
        The temperature of the plasma (eV).
    jx : int
        The number of grid points in the momentum direction.
    iy : int
        The number of grid points in the polar angle direction.
    enorm : scalar
        The maximum energy on the momentum grid (keV).

    """

    def __init__(self, temperature, jx=300, iy=200, enorm=400):
        f, p, theta = self._define_distribution(temperature, jx, iy, enorm)
        u = p * (1e2 * c)  # c is in SI units, u in CGS.
        super().__init__(f, u, theta)

    def _define_distribution(self, temperature, jx, iy, enorm):
        """Define the Maxwell-Jüttner distribution."""
        enorm *= 1e3 * e / (m_e * c**2)  # keV to mc^2
        gammanorm = 1 + enorm
        pnorm = np.sqrt(gammanorm**2 - 1)
        print("pnorm:", pnorm)
        p = np.linspace(0, pnorm, jx)
        theta = np.linspace(0, np.pi, iy)
        p_grid, _ = np.meshgrid(p, theta, indexing='ij')
        f = self._relativistic_maxwellian(p_grid, temperature)
        return f, p, theta

    @staticmethod
    def _relativistic_maxwellian(p, temperature):
        """
        Calculate the amplitude of the Maxwell-Jüttner distribution
        at momentum `p`.
        """
        temperature *= e / (m_e * c**2)  # eV to mc^2
        gamma = np.hypot(1, p)
        k2 = special.kv(2, 1.0 / temperature)
        prefactor = 4 * np.pi * temperature * k2
        return np.exp(-gamma / temperature) / prefactor
